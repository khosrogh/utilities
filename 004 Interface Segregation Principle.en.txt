
Chapter four. Interface Segregation Principle.
This chapter is all about keeping interfaces cohesive.
You know what the purpose of an interface is, an interface defines a signature that must be implemented
by classes that implement that interface.
That same interface can now be used as a parameter type for constructors or properties of other classes.
This is the magic behind dependancy inversion that we will look at in the next chapter.
For now, we will focus on the interface itself.
I hear you think. Interface? But Python does not have interfaces.
That's true.
We can create base classes or abstract base classes and use multiple inheritance to inherit from them.
But in a dynamic language like Python, an interface does not have to be a physical thing at all.
An interface exists at the moment when we specify it in our designs.
For example, look at the class diagrams on the screen. Both classes have a method raise_salary
that seems public.
Can you guess what the common interface for both classes is?
Here it is. The task of an interface is to describe the signature of the class.
Now we know what an interface is. So what is the interface segregation principle?
The interface segregation principle says that no client should be forced to depend on methods it does
not use. This sounds plausible, and yet it is very easy to violate the principle.
Let me give you an example of such violation.
We are going to write a class for an iPhone, our iPhone can make phone calls and can be unlocked by
swiping.
Here is the code.
You can see the method to make a phone call and a method to unlock the phone. If we would extract an
interface from this class, it would look something like this.
At this point, you could create a bunch of smart phones that all implement the phone interface.
But now we want to create a class for a Nokia 2720.
This is a feature phone without a touchscreen.
When we implement the code for this phone, we see a problem.
What does this phone do when swipe_to_unlock is called?
Right now, it would raise an error and the problem is that there is not much we can do to improve the
situation.
The best thing we can do is override the method and add some information to the error, but the reality
is that this method should not be known at all in the Nokia class.
Clients of the class would always have to check if the phone is a Nokia to prevent calling swipe_to_unlock
.
As you have seen in Chapter three, this violates the Liskov substitution principle, but why does
it also violate the interface segregation principle?
The phone interface has two roles, one role has something to do with making phone calls and the other
has something to do with touch screens, but both roles are combined in a single interface.
The interface forces a phone without a touch screen to deal with touch functionality.
That interface is not coherent.
This is a violation of the interface segregation principle.
The solution is to break up the interface by its roles.
Here is the old interface called Phone.
I'm going to split it in two interfaces.
One interface for phone calls and one for touch functionality.
Now, the iPhone class can use multiple inheritance to inherit from both interfaces.
And the Nokia class only inherits from the phonecall interface. The swipe_to_unlock method is now fully
unknown to the Nokia class.
We have successfully broken up the single incohesive interface into two cohesive interfaces that are grouped
by their rules and do not violate the interface segregation principle anymore.
So what happens when new functions are added to the phone classes?
Let's start with an emergency call.
Before we started with interface segregation, we would have asked ourselves this question: what phones
can make an emergency call?
But now we ask ourselves the question to what role belongs making phone calls?
The answer is easy.
An emergency call should be added to the phonecall interface.
Here is another example, text messages.
All phones support text messages, so in what interface do we put the method?
We could put it into phonecall interface, but that would add another role to the phonecall interface
and violates the interface segregation principle.
The solution is clear, we need to introduce a third interface.
And this is how interface segregation works, we break up the interface in groups of functions.
This prevents subclasses from being polluted by methods they do not use.
Conclusion.
Whenever clients depend on so-called 'fat interfaces', but only use few methods from it, you might be
looking at a violation of the interface segregation principle.
The goal is to create cohesive interfaces by breaking up in groups of functions.
Watch out that breaking up interfaces does not become the goal itself.
It is possible to overdo interface segregation.
Finding a good balance is key here.
You have seen the first four principles of solid.
We started with the single responsibility principle that states that things should only have one reason
to change.
We continued with the open-closed principle while we saw it is indeed possible to extend software with
a minimal amount of changes in existing code.
The Liskov substitution principle showed how important it is that subclasses do not change the behavior
of super classes in unexpected ways.
And we just have seen how to break up interfaces to adhere to the interface segregation principle.
If I would have to pick two favorite principles, it would be the open-closed principle and the one
we are going to look at next.
A dependency inversion principle.
What is it about? You'll learn that in the next and final chapter of this course.
