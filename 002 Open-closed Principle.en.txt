
Chapter two. Open-closed principle. This principle causes a lot of confusion for developers who first
hear it.
Open-closed means open for extension, but closed for modification.
That might even make it more confusing.
How can a program be extended if you cannot change it?
Surely you have to modify existing code to add new functionality.
Yes, but if you stick to this principle, the changes do not explode into all directions.
Perhaps you recognize code like this. This is a selection that switches on object types. The reason
to use the open-closed principle is easy.
It prevents switches like this.
Why is this important?
First, I'll show you how a selection on types violates the open closed principle and how to solve
it.
Then I show how easy it is to add new functionality when we adhere to the principle.
Finally, I will remove existing functionality to show how we can do it with the least amount of risk.
Let me start by showing you problematic code.
Here is a base class called Employee, it stores an employee name.
Look at the print_employee function, it takes a reference to an object of type employee. It prints the
name of the employee.
So far, so good.
Now the system needs to be extended with a manager class.
A manager inherits from employee and adds an attribute: department.
Here is the code that adds the manager class.
Manager inherits from employee and adds an extra attribute to the object: department.
I overload the initializer to support the department attribute.
At this point, e can be an object of type employee or manager.
We know that e has a name, but we don't know if e has a department.
The print_employee function needs a switch to check the type of e.
In order to check for the type, the switch needs to know all possible employee types.
When the print_employee function is moved to a different module, this problem becomes even more visible
because to know every employee type, they need to be imported.
And this switch can be in multiple places. Every time a new employee subclass is created, you have
to change the code in all those places.
It now becomes very clear that we cannot extend the functionality without changing existing working
code.
And there is the risk of changing the code in one place, but forget it in another place.
This example is a violation of the open-closed principle.
The good news is that it is a solvable problem. And the technique to solve the problem is polymorphism.
The employee will get a new method called get_info that returns employee information.
The manager will override this method to return manager information.
This is how the code looks like.
get_info in the employee class returns the employee name.
get_info in the manager class returns the name plus department.
The print_employee function does not have to know anymore what type e is.
All it needs to do is to make a polymorphic call  to get_info, to get the proper employee information.
You just saw how switching on object types violates the open-closed principle. You also saw how to
solve the problem with polymorphism.
At this point, extending functionality becomes very easy.
Let me add a new employee type to the system. The employee type is a programmer. It inherits from
employee and adds an extra attribute called programming_language.
Since we adhere to the open closed principle, all we need to do is to add a new class that overloads
the get_info method properly.
And instead of having to add an extra case to check if the type of e is programmer, we did not have
to change to print_employee function at all.
And that is what we call open for extension, closed for modification.
Another huge benefit of working with the open-closed principle is that removing functionality can be
done relatively safe.
Let's say that the company finally realized it does not really need managers and asks you to remove
everything that has something to do with manager objects.
You don't have to think about this too long. Since there are no switches in the code, that check for
the manager object type, you can just delete the manager class.
Perhaps you will have to clean up some places where managers were instantiated in the code, but that
is as easy as running the code and see what errors occur when the code is compiled.
And that's it, you just learned one of the most important principles in software engineering.
Whenever you see if-else statements or switches that select on object types, you might be looking at
a violation of the open-closed principle.
The open-closed principle is one of my favorites and is closely related to the next principle, the
Liskov substitution principle.
