
Chapter one. Single responsibility principle.
This is the first of the five principles. What is it?
The idea of the single responsibility principle is that classes or modules only have a single reason
to change. The word reason might be confusing here.
A class can do more than one thing
obviously. This principle is not about keeping classes small.
The goal here is to prevent a class from changing all the time for all sorts of reasons.
I'll give you an example. Class one contains functionality A and functionality B. If you change A,
you can break B just from the fact that they share the same class.
You have seen these kinds of problems, big classes with lots of code are intimidating.
When you change something, you just have to hope you did not break something else.
But there are more problems.
Let me give you a list of them.
One. Classes get big when they have many responsibilities. Naming the class is hard and finding code
is hard.
Two. Mixing responsibilities. We will look at an example of an employee class that mixes responsibilities
and find out it is dangerous to change code around unrelated other code.
Three. Dependencies on libraries. I will give you an example, where a harmless dependancy in one class
starts to invade another unrelated class.
Let's start with a common example of the single responsibility principle and how it is violated.
It concerns a class that does too many different things.
Look at the employee class. It stores a name and salary.
The employee class also has some business logic to raise the salary.
Until here, we all consider this to be business logic.
But the class can also save an employee as XML.
And print a report of the employee.
The name of the class implies an employee entity, but the class does more than that.
It also handles storage and reporting. You would not expect this by just looking at the class name.
The class name should tell us what it is responsible for.
If you see big class names like this, it might be the first clue that the class is doing too many different
things.
As you see, naming is hard, but also finding code in such classes is hard.
And our problems are only starting to get bigger from here.
Clearly, the employee class has mixed responsibilities.
Let's look at a practical problem that arises.
Look at the employee class again. For this example, I have removed the reporting function. Employee now
has two responsibilities: Business logic and storage logic.
I implement the save_as_xml method. It opens the file emp.xml and writes XML to it.
Look at the file name.
It is hard coded. To make it more flexible for users of the class, the file name will be defined as
a class variable at the top of the class.
The variable is created.
And used in the function.
Notice how the code for the two responsibilities is now scattered all over the class. And there is a
new subtle problem.
The class variable with the file name is only used by the storage part. User of this class start reading
the code from the top and asked themselves, why does this class know anything about XML file names?
The user now has to scan the code to find out it has nothing to do with the business logic, but with
the later added storage responsibility.
This problem will get worse when we change the class again.
At this point, the employee can be saved as XML, but now we want to replace XML with JSON.
The first thing we do is remove the save_as_xml function.
That cleans up to code, but wait a minute.
We forgot the class variable xml_filename.
Imagine someone looking at this code in six months.
Will this person be brave enough to delete the variable?
You see that when responsibilities are mixed,
it is not only harder to add new code, but you can also not safely delete code and be sure you have
not forgotten something.
Look at the employee class diagram. We have removed the save_as_xml method, but need to replace it
with the save_as_json method.
But if we add the save_as_json method, it will cause the same problems as before.
Clearly, we are violating the single responsibility principle.
I will show you even more violations, but before I do, I'd like to show you how the problem is solved.
We know that the class is doing too many things and we need to split it up in multiple classes.
First, we identify the responsibilities.
The employee class contains business logic
and storage logic. The storage logic will be moved to its own class.
When classes are split up, new problems are introduced:  Missing dependencies. The save_as_json method
is now in the EmployeeStorage class.
How does it get access to an employee object? For now
We choose the simplest solution.
We pass it when we call the save_as_json function.
Here is the employee storage class.
One thing is immediately clear. Every line of code in this class has something to do with employee storage.
The employee class is stripped of storage logic and only contains business logic.
And how do we connect both classes?
We do this in main.
Main imports both classes.
An employee object is created, followed by an employee storage object.
And finally the save_as_json method is called and an employee object is passed to the function.
Here is a dependency diagram of the program we just created.
As I said before, OO allows us to manage our dependencies and the S.O.L.I.D. principles use this kind
of dependency management.
We will discuss dependency management further in the dependency inversion principle chapter.
But now we continue with the single responsibility principle.
At this point, we have achieved single responsibility in both classes.
But we have to be careful because we can violate the principle again very easy.
Let me give you another example.
Sometimes we violate the single responsibility principle in very subtle ways.
In the following example, extra responsibilities sneak in through an external library.
Look at the save_as_json method.
The method constructs the JSON manually, and this is error prone.
You found a library online that serializes and saves JSON in a single line of code.
All we need to do is import jsonlibrary.
And call jsonlibrary.save.
We run the program and get an error.
The JSON library tries to serialize the employee object. To do this, it searches for serializable
attributes. But we have not marked name and salary as serializable.
No problem.
The error shows that all we need to do is to decorate the attributes with @jsonserializable.
Let's do it now.
I add the two decorators and a question rises.
Where do the decorators come from?
The answer is that they come from the JSON library. That means we have to import jsonlibrary in the
employee class.
And this makes it very clear. Our goal was to get rid of all storage functionality in the employee class
and suddenly the employee is polluted with knowledge about JSON serialisation.
Think about the complications here, it becomes impossible to move the employee entity to another project
without installing the JSON library here. And whenever JSON serialisation becomes obsolete, we need
to make changes to the employee class, which should be unaware of all things related to JSON.
How would you solve a problem like this?
There is only one way to solve it without breaking the single responsibility principle.
On the left, you see the employee class that should not know anything about JSON.
On the right, there is the employee storage class that needs a serializable employee object. The boundary
in the middle separates the entities from the storage logic.
A new class has created: JSONEmployee.
It is also hosted in the storage module. Its only purpose is to provide a copy of the employee data
attributes and mark them JSON serializable.
Each data attribute is copied from the employee object to the JSONEmployee object.
Then the JSONEmployee object is passed to the save_as_json method.
Something similar happens for de-serializing.
I've worked on many projects where colleagues protested against this extra object in the middle.
I understand them because it seems to be a lot of extra work when all the data attributes for a lot
of objects needs to be copied.
But if you want to respect the single responsibility principle, the employee object must not know about
JSON.
There are more examples of violations like this. You'll find them in object relational mapper frameworks.
In such frameworks, entities get multiple responsibilities.
Like storing data.
Provide UI labels.
Validate data.
And provide error messages.
Let me show you an example of such classes.
The employee class starts as a business object to store employee data.
But suddenly it is also responsible for labels on the screen.
And even error messages on the screen. This class is now responsible for many things and violates the
single responsibility principle.
Conclusion. When the single responsibility principle is violated, your classes get bigger and it gets
more risky to change code without affecting other code.
Sometimes more subtle violations happen, like in the decorator examples. Keep an eye on the import
statements in your classes, they can provide clues for these kinds of violations.
