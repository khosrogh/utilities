
Chapter three. Liskov substitution principle.
This principle is all about expectations.
The idea behind this principle is that subclasses should not change the behavior of super classes in
unexpected ways.
This principle is closely related to the open-closed principle.
Violations of the Liskov substitution principle usually show us where the open-closed principle is
violated.
The technical description of the Liskov substitution principle goes something like this.
If B is a subtype of A, objects of type A may be replaced with objects of type B without breaking things.
Sounds great, but what does it mean?
I will show that by deliberately violate the principle and break the design of the code.
Before I show the code, I already want to tell you how to adhere to the principle. Again, we use
polymorphism.
You might wonder, isn't there anything polymorphism cannot do for us?
Well, the answer is yes.
Liskov substitution violations sometimes also indicate design flaws, and here polymorphism won't save
us.
We just have to redesign parts of the code.
I will show four ways to violate the Liskov substitution principle.
One. Selecting on types.
Two. Break the is-a relationship of inheritance.
Three. Raise errors in overridden methods.
Four. Breaking constraints.
Let's start with the first example of a violation of the Liskov substitution principle.
It is one of the most common violations of the principle. A selection on types. We have already seen
this problem in the last chapter on the open-closed principle.
Let me quickly repeat what it was about.
There is a base class.
And a subclass that implements extra attributes.
A function that takes a reference to an employee object now has to check what type of object e is.
In order to check for the type, the switch must know all possible employee types, and so it violates
the open-closed principle.
And since supertype employee cannot be replaced by subtype manager without checking the type of e,
the Liskov substitution principle is also violated.
You have seen how to solve the problem in the previous chapter.
The second example of a Liskov substitution violation is more subtle.
When classes inherit from each other, we say they have an is-a relationship.
For this example, I'll create an employee class and inherit an intern class from it.
We assume an intern is an employee.
I start with an employee class that stores a name and salary.
I create a method that prints the name and year salary.
Finally, I create an employee and call the method print_year_salary.
The system should also support interns. In our system, interns are employees without salaries.
Since the intern has no salary at all, the salary should not be zero, but set to None.
This is done in the initializer. The initializer is overridden and passes None to the super initializer
or.
That way, the salary will always be none, no matter what salary the intern is instantiated with.
This leads to a problem.
When the year salary for an intern is printed, an error occurs because although it looks like Dave's (edit: Chuck in the code)
salary is zero, the intern class overwrites to value with None.
Here is the full code.
The intern class changes the behavior of the superclass in unexpected ways by setting the salary to
none.
Perhaps you think, why not set the value to zero?
That way the code will not crash.
That's true, but that would create another problem.
For example, interns would lower the average salary of all employees, even if they don't have a salary
at all.
The solution here is simple, even if an intern is an employee, for all normal intents and purposes,
an intern object is not an employee object because the behavior is not consistent.
The print_year_salary function would have to check the employee type to work properly, but that would
violate the open-closed principle.
This is an example where polymorphism cannot help us, and the conclusion is that the intern class should
not be inherited from the employee class. An intern object does not have an is-a relationship with
an employee object.
You just saw that breaking the is-a relationship can violate the Liskov substitution principle. There
is another example that breaks
the is-a relationship.
It is caused when overridden methods raise errors that are not inherited from errors raised by the parent
class.
A common example is a not implemented error.
An employee can be promoted by calling the promote method.
Class intern inherits from employee, but an intern cannot be promoted. The promotion effort is overridden
and raises NotImplementedError.
The promote_employee function takes an employee and calls promote on it.
The same problem as in the previous example occurs. An intern object is not an employee object because
the behavior is not consistent.
The promote_employee function would have to check the type of e to know if it should call the promote
method.
The overridden promote method raises an error that is never raised by the method it overrides.
This is a violation of the Liskov substitution principle.
The last violation I'm going to show is ignoring class constraints. An example of this violation is
when subclasses change values without checking constraints.
Class employee takes an employee_id and name. Both parameters are stored in the object.
The employee class has a method to check if the employee_id is valid. The employee_id must be a number
greater than zero.
Class Intern is added to the system and overrides the initializer. For now, it just calls the initializer
of the base class.
An Intern object is created and the system checks if the object is valid. The result is true.
Now, the personnel department wants to see a list of employees and asks if the employee IDs of the
interns can be prefixed with the letter I.
This would ask for a change in the reporting module, but time is short and the developer creates a hack.
The developer prefixes the letter I when the initializer of the superclass is called.
This will result in the desired report, but it also violates the employee ID constraint.
The constraint specified that the employee_id must be a valid number, greater than zero.
When the is_employee_id_valid method is called, it will return false.
The subclass has violated the constraint.
Conclusion.
It doesn't matter how tiny the change of behavior in a subclass is, as soon as the subclass starts
to change the behavior in unexpected ways, the subclass does not have an is-a relationship with its
superclass anymore. From our examples with the intern subclass,
there is a simple conclusion to draw.
An intern object is not an employee object, according to our system.
Liskov substitution principle violations can be difficult to detect and even harder to solve when the
system is already in use.
If we do not spot them early on, at one point, the only practical solution is to implement if-else
statements and thus break to open-closed principle. Sometimes it would be better just to accept right
from the start that some classes do not have an is-a relationship.
