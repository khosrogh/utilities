1
00:00:02,080 --> 00:00:05,890
Chapter three. Liskov substitution principle.

2
00:00:07,440 --> 00:00:10,650
This principle is all about expectations.

3
00:00:13,770 --> 00:00:20,250
The idea behind this principle is that subclasses should not change the behavior of super classes in

4
00:00:20,250 --> 00:00:21,570
unexpected ways.

5
00:00:22,660 --> 00:00:26,860
This principle is closely related to the open-closed principle.

6
00:00:28,490 --> 00:00:34,880
Violations of the Liskov substitution principle usually show us where the open-closed principle is

7
00:00:34,880 --> 00:00:35,660
violated.

8
00:00:38,720 --> 00:00:43,970
The technical description of the Liskov substitution principle goes something like this.

9
00:00:45,230 --> 00:00:55,130
If B is a subtype of A, objects of type A may be replaced with objects of type B without breaking things.

10
00:00:56,790 --> 00:00:59,080
Sounds great, but what does it mean?

11
00:00:59,940 --> 00:01:04,740
I will show that by deliberately violate the principle and break the design of the code.

12
00:01:07,210 --> 00:01:14,020
Before I show the code, I already want to tell you how to adhere to the principle. Again, we use

13
00:01:14,020 --> 00:01:14,980
polymorphism.

14
00:01:16,640 --> 00:01:21,110
You might wonder, isn't there anything polymorphism cannot do for us?

15
00:01:22,010 --> 00:01:23,570
Well, the answer is yes.

16
00:01:24,170 --> 00:01:32,840
Liskov substitution violations sometimes also indicate design flaws, and here polymorphism won't save

17
00:01:32,840 --> 00:01:33,150
us.

18
00:01:33,830 --> 00:01:36,110
We just have to redesign parts of the code.

19
00:01:37,070 --> 00:01:41,420
I will show four ways to violate the Liskov substitution principle.

20
00:01:43,620 --> 00:01:45,870
One. Selecting on types.

21
00:01:47,630 --> 00:01:51,560
Two. Break the is-a relationship of inheritance.

22
00:01:52,890 --> 00:01:56,430
Three. Raise errors in overridden methods.

23
00:01:57,900 --> 00:01:59,880
Four. Breaking constraints.

24
00:02:01,590 --> 00:02:06,870
Let's start with the first example of a violation of the Liskov substitution principle.

25
00:02:08,330 --> 00:02:15,080
It is one of the most common violations of the principle. A selection on types. We have already seen

26
00:02:15,080 --> 00:02:18,320
this problem in the last chapter on the open-closed principle.

27
00:02:18,770 --> 00:02:21,050
Let me quickly repeat what it was about.

28
00:02:23,240 --> 00:02:24,500
There is a base class.

29
00:02:26,540 --> 00:02:29,600
And a subclass that implements extra attributes.

30
00:02:32,950 --> 00:02:39,790
A function that takes a reference to an employee object now has to check what type of object e is.

31
00:02:41,830 --> 00:02:48,280
In order to check for the type, the switch must know all possible employee types, and so it violates

32
00:02:48,280 --> 00:02:49,840
the open-closed principle.

33
00:02:51,230 --> 00:02:58,520
And since supertype employee cannot be replaced by subtype manager without checking the type of e,

34
00:02:58,940 --> 00:03:02,390
the Liskov substitution principle is also violated.

35
00:03:03,830 --> 00:03:07,160
You have seen how to solve the problem in the previous chapter.

36
00:03:09,360 --> 00:03:14,070
The second example of a Liskov substitution violation is more subtle.

37
00:03:15,340 --> 00:03:21,010
When classes inherit from each other, we say they have an is-a relationship.

38
00:03:22,230 --> 00:03:27,940
For this example, I'll create an employee class and inherit an intern class from it.

39
00:03:28,350 --> 00:03:31,680
We assume an intern is an employee.

40
00:03:34,810 --> 00:03:38,440
I start with an employee class that stores a name and salary.

41
00:03:40,080 --> 00:03:43,620
I create a method that prints the name and year salary.

42
00:03:45,570 --> 00:03:50,010
Finally, I create an employee and call the method print_year_salary.

43
00:03:53,260 --> 00:04:00,880
The system should also support interns. In our system, interns are employees without salaries.

44
00:04:01,420 --> 00:04:08,260
Since the intern has no salary at all, the salary should not be zero, but set to None.

45
00:04:11,060 --> 00:04:18,500
This is done in the initializer. The initializer is overridden and passes None to the super initializer

46
00:04:18,500 --> 00:04:18,710
or.

47
00:04:19,890 --> 00:04:26,640
That way, the salary will always be none, no matter what salary the intern is instantiated with.

48
00:04:27,780 --> 00:04:29,310
This leads to a problem.

49
00:04:34,270 --> 00:04:41,380
When the year salary for an intern is printed, an error occurs because although it looks like Dave's (edit: Chuck in the code)

50
00:04:41,390 --> 00:04:47,200
salary is zero, the intern class overwrites to value with None.

51
00:04:51,450 --> 00:04:52,590
Here is the full code.

52
00:04:53,770 --> 00:05:00,700
The intern class changes the behavior of the superclass in unexpected ways by setting the salary to

53
00:05:00,880 --> 00:05:01,510
none.

54
00:05:03,060 --> 00:05:06,870
Perhaps you think, why not set the value to zero?

55
00:05:07,410 --> 00:05:09,240
That way the code will not crash.

56
00:05:10,140 --> 00:05:13,080
That's true, but that would create another problem.

57
00:05:14,090 --> 00:05:22,280
For example, interns would lower the average salary of all employees, even if they don't have a salary

58
00:05:22,280 --> 00:05:22,880
at all.

59
00:05:25,960 --> 00:05:33,160
The solution here is simple, even if an intern is an employee, for all normal intents and purposes,

60
00:05:33,550 --> 00:05:39,700
an intern object is not an employee object because the behavior is not consistent.

61
00:05:41,080 --> 00:05:47,860
The print_year_salary function would have to check the employee type to work properly, but that would

62
00:05:47,860 --> 00:05:49,900
violate the open-closed principle.

63
00:05:52,850 --> 00:06:00,080
This is an example where polymorphism cannot help us, and the conclusion is that the intern class should

64
00:06:00,080 --> 00:06:08,120
not be inherited from the employee class. An intern object does not have an is-a relationship with

65
00:06:08,120 --> 00:06:09,380
an employee object.

66
00:06:12,310 --> 00:06:19,600
You just saw that breaking the is-a relationship can violate the Liskov substitution principle. There

67
00:06:19,600 --> 00:06:21,420
is another example that breaks

68
00:06:21,520 --> 00:06:23,440
the is-a relationship.

69
00:06:25,290 --> 00:06:32,490
It is caused when overridden methods raise errors that are not inherited from errors raised by the parent

70
00:06:32,490 --> 00:06:33,030
class.

71
00:06:34,370 --> 00:06:37,540
A common example is a not implemented error.

72
00:06:40,040 --> 00:06:43,760
An employee can be promoted by calling the promote method.

73
00:06:45,670 --> 00:06:53,620
Class intern inherits from employee, but an intern cannot be promoted. The promotion effort is overridden

74
00:06:53,620 --> 00:06:56,080
and raises NotImplementedError.

75
00:06:58,430 --> 00:07:03,050
The promote_employee function takes an employee and calls promote on it.

76
00:07:04,100 --> 00:07:11,330
The same problem as in the previous example occurs. An intern object is not an employee object because

77
00:07:11,330 --> 00:07:13,280
the behavior is not consistent.

78
00:07:15,210 --> 00:07:21,090
The promote_employee function would have to check the type of e to know if it should call the promote

79
00:07:21,090 --> 00:07:21,570
method.

80
00:07:24,550 --> 00:07:30,890
The overridden promote method raises an error that is never raised by the method it overrides.

81
00:07:31,360 --> 00:07:35,050
This is a violation of the Liskov substitution principle.

82
00:07:39,050 --> 00:07:46,340
The last violation I'm going to show is ignoring class constraints. An example of this violation is

83
00:07:46,340 --> 00:07:50,600
when subclasses change values without checking constraints.

84
00:07:53,410 --> 00:08:00,400
Class employee takes an employee_id and name. Both parameters are stored in the object.

85
00:08:02,070 --> 00:08:10,050
The employee class has a method to check if the employee_id is valid. The employee_id must be a number

86
00:08:10,050 --> 00:08:11,310
greater than zero.

87
00:08:16,170 --> 00:08:23,640
Class Intern is added to the system and overrides the initializer. For now, it just calls the initializer

88
00:08:23,640 --> 00:08:24,900
of the base class.

89
00:08:28,410 --> 00:08:35,040
An Intern object is created and the system checks if the object is valid. The result is true.

90
00:08:39,540 --> 00:08:46,590
Now, the personnel department wants to see a list of employees and asks if the employee IDs of the

91
00:08:46,590 --> 00:08:49,920
interns can be prefixed with the letter I.

92
00:08:51,250 --> 00:08:57,760
This would ask for a change in the reporting module, but time is short and the developer creates a hack.

93
00:09:01,090 --> 00:09:06,790
The developer prefixes the letter I when the initializer of the superclass is called.

94
00:09:07,760 --> 00:09:14,420
This will result in the desired report, but it also violates the employee ID constraint.

95
00:09:16,680 --> 00:09:23,040
The constraint specified that the employee_id must be a valid number, greater than zero.

96
00:09:28,360 --> 00:09:33,470
When the is_employee_id_valid method is called, it will return false.

97
00:09:34,270 --> 00:09:36,820
The subclass has violated the constraint.

98
00:09:41,210 --> 00:09:42,020
Conclusion.

99
00:09:43,030 --> 00:09:50,680
It doesn't matter how tiny the change of behavior in a subclass is, as soon as the subclass starts

100
00:09:50,680 --> 00:09:58,360
to change the behavior in unexpected ways, the subclass does not have an is-a relationship with its

101
00:09:58,360 --> 00:10:03,040
superclass anymore. From our examples with the intern subclass,

102
00:10:03,250 --> 00:10:05,380
there is a simple conclusion to draw.

103
00:10:06,740 --> 00:10:11,270
An intern object is not an employee object, according to our system.

104
00:10:12,170 --> 00:10:18,830
Liskov substitution principle violations can be difficult to detect and even harder to solve when the

105
00:10:18,830 --> 00:10:20,620
system is already in use.

106
00:10:22,060 --> 00:10:29,620
If we do not spot them early on, at one point, the only practical solution is to implement if-else

107
00:10:29,620 --> 00:10:37,150
statements and thus break to open-closed principle. Sometimes it would be better just to accept right

108
00:10:37,150 --> 00:10:42,250
from the start that some classes do not have an is-a relationship.
