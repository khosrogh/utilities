1
00:00:01,610 --> 00:00:05,690
Chapter four. Interface Segregation Principle.

2
00:00:06,410 --> 00:00:10,520
This chapter is all about keeping interfaces cohesive.

3
00:00:12,940 --> 00:00:20,110
You know what the purpose of an interface is, an interface defines a signature that must be implemented

4
00:00:20,110 --> 00:00:23,170
by classes that implement that interface.

5
00:00:25,110 --> 00:00:32,400
That same interface can now be used as a parameter type for constructors or properties of other classes.

6
00:00:33,090 --> 00:00:38,580
This is the magic behind dependancy inversion that we will look at in the next chapter.

7
00:00:39,330 --> 00:00:42,360
For now, we will focus on the interface itself.

8
00:00:44,870 --> 00:00:50,310
I hear you think. Interface? But Python does not have interfaces.

9
00:00:51,020 --> 00:00:51,750
That's true.

10
00:00:52,580 --> 00:00:59,470
We can create base classes or abstract base classes and use multiple inheritance to inherit from them.

11
00:01:00,900 --> 00:01:06,950
But in a dynamic language like Python, an interface does not have to be a physical thing at all.

12
00:01:08,000 --> 00:01:12,620
An interface exists at the moment when we specify it in our designs.

13
00:01:15,280 --> 00:01:22,510
For example, look at the class diagrams on the screen. Both classes have a method raise_salary

14
00:01:22,630 --> 00:01:23,740
that seems public.

15
00:01:24,460 --> 00:01:27,640
Can you guess what the common interface for both classes is?

16
00:01:29,540 --> 00:01:35,330
Here it is. The task of an interface is to describe the signature of the class.

17
00:01:36,600 --> 00:01:42,240
Now we know what an interface is. So what is the interface segregation principle?

18
00:01:45,590 --> 00:01:52,070
The interface segregation principle says that no client should be forced to depend on methods it does

19
00:01:52,070 --> 00:01:57,890
not use. This sounds plausible, and yet it is very easy to violate the principle.

20
00:01:58,900 --> 00:02:01,650
Let me give you an example of such violation.

21
00:02:03,820 --> 00:02:10,870
We are going to write a class for an iPhone, our iPhone can make phone calls and can be unlocked by

22
00:02:10,870 --> 00:02:11,530
swiping.

23
00:02:15,020 --> 00:02:15,830
Here is the code.

24
00:02:17,160 --> 00:02:23,490
You can see the method to make a phone call and a method to unlock the phone. If we would extract an

25
00:02:23,490 --> 00:02:27,180
interface from this class, it would look something like this.

26
00:02:32,110 --> 00:02:37,900
At this point, you could create a bunch of smart phones that all implement the phone interface.

27
00:02:40,870 --> 00:02:45,170
But now we want to create a class for a Nokia 2720.

28
00:02:46,030 --> 00:02:48,880
This is a feature phone without a touchscreen.

29
00:02:50,740 --> 00:02:54,160
When we implement the code for this phone, we see a problem.

30
00:02:55,910 --> 00:02:59,780
What does this phone do when swipe_to_unlock is called?

31
00:03:01,200 --> 00:03:07,740
Right now, it would raise an error and the problem is that there is not much we can do to improve the

32
00:03:07,740 --> 00:03:08,700
situation.

33
00:03:10,980 --> 00:03:17,790
The best thing we can do is override the method and add some information to the error, but the reality

34
00:03:17,790 --> 00:03:22,560
is that this method should not be known at all in the Nokia class.

35
00:03:23,710 --> 00:03:29,830
Clients of the class would always have to check if the phone is a Nokia to prevent calling swipe_to_unlock

36
00:03:29,830 --> 00:03:30,370
.

37
00:03:32,010 --> 00:03:38,910
As you have seen in Chapter three, this violates the Liskov substitution principle, but why does

38
00:03:38,910 --> 00:03:42,600
it also violate the interface segregation principle?

39
00:03:44,710 --> 00:03:51,340
The phone interface has two roles, one role has something to do with making phone calls and the other

40
00:03:51,340 --> 00:03:57,430
has something to do with touch screens, but both roles are combined in a single interface.

41
00:03:58,120 --> 00:04:03,850
The interface forces a phone without a touch screen to deal with touch functionality.

42
00:04:04,600 --> 00:04:06,620
That interface is not coherent.

43
00:04:07,570 --> 00:04:11,410
This is a violation of the interface segregation principle.

44
00:04:14,080 --> 00:04:17,380
The solution is to break up the interface by its roles.

45
00:04:19,410 --> 00:04:21,390
Here is the old interface called Phone.

46
00:04:22,540 --> 00:04:25,150
I'm going to split it in two interfaces.

47
00:04:26,280 --> 00:04:30,330
One interface for phone calls and one for touch functionality.

48
00:04:33,020 --> 00:04:38,450
Now, the iPhone class can use multiple inheritance to inherit from both interfaces.

49
00:04:40,830 --> 00:04:47,550
And the Nokia class only inherits from the phonecall interface. The swipe_to_unlock method is now fully

50
00:04:47,550 --> 00:04:49,200
unknown to the Nokia class.

51
00:04:52,320 --> 00:05:00,630
We have successfully broken up the single incohesive interface into two cohesive interfaces that are grouped

52
00:05:00,630 --> 00:05:05,890
by their rules and do not violate the interface segregation principle anymore.

53
00:05:06,810 --> 00:05:10,410
So what happens when new functions are added to the phone classes?

54
00:05:13,730 --> 00:05:15,710
Let's start with an emergency call.

55
00:05:16,690 --> 00:05:24,310
Before we started with interface segregation, we would have asked ourselves this question: what phones

56
00:05:24,550 --> 00:05:26,320
can make an emergency call?

57
00:05:27,830 --> 00:05:32,930
But now we ask ourselves the question to what role belongs making phone calls?

58
00:05:35,370 --> 00:05:36,400
The answer is easy.

59
00:05:36,780 --> 00:05:40,740
An emergency call should be added to the phonecall interface.

60
00:05:44,170 --> 00:05:46,930
Here is another example, text messages.

61
00:05:47,930 --> 00:05:53,210
All phones support text messages, so in what interface do we put the method?

62
00:05:54,360 --> 00:06:01,020
We could put it into phonecall interface, but that would add another role to the phonecall interface

63
00:06:01,020 --> 00:06:03,990
and violates the interface segregation principle.

64
00:06:06,130 --> 00:06:10,870
The solution is clear, we need to introduce a third interface.

65
00:06:13,250 --> 00:06:19,530
And this is how interface segregation works, we break up the interface in groups of functions.

66
00:06:20,090 --> 00:06:25,400
This prevents subclasses from being polluted by methods they do not use.

67
00:06:29,720 --> 00:06:30,470
Conclusion.

68
00:06:31,630 --> 00:06:39,220
Whenever clients depend on so-called 'fat interfaces', but only use few methods from it, you might be

69
00:06:39,220 --> 00:06:43,420
looking at a violation of the interface segregation principle.

70
00:06:44,930 --> 00:06:50,330
The goal is to create cohesive interfaces by breaking up in groups of functions.

71
00:06:53,190 --> 00:06:57,150
Watch out that breaking up interfaces does not become the goal itself.

72
00:06:57,450 --> 00:07:00,810
It is possible to overdo interface segregation.

73
00:07:01,290 --> 00:07:03,600
Finding a good balance is key here.

74
00:07:06,820 --> 00:07:09,040
You have seen the first four principles of solid.

75
00:07:10,780 --> 00:07:17,200
We started with the single responsibility principle that states that things should only have one reason

76
00:07:17,200 --> 00:07:17,950
to change.

77
00:07:19,990 --> 00:07:27,010
We continued with the open-closed principle while we saw it is indeed possible to extend software with

78
00:07:27,010 --> 00:07:30,100
a minimal amount of changes in existing code.

79
00:07:32,880 --> 00:07:40,380
The Liskov substitution principle showed how important it is that subclasses do not change the behavior

80
00:07:40,380 --> 00:07:43,160
of super classes in unexpected ways.

81
00:07:45,730 --> 00:07:52,450
And we just have seen how to break up interfaces to adhere to the interface segregation principle.

82
00:07:53,740 --> 00:08:00,580
If I would have to pick two favorite principles, it would be the open-closed principle and the one

83
00:08:00,730 --> 00:08:02,350
we are going to look at next.

84
00:08:04,040 --> 00:08:06,210
A dependency inversion principle.

85
00:08:07,040 --> 00:08:12,680
What is it about? You'll learn that in the next and final chapter of this course.
